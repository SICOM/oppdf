/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <errno.h>
#include <inttypes.h>
#include <malloc.h>
#include <math.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <gtk/gtk.h>
#include <gdk/gdkx.h> 
#include <poppler/glib/poppler.h>

#include "support.h"
#include "interface.h"

scale	scales[13] = {
	{ "Best Fit", BESTFIT },
	{ "Fit Page Width", FITPAGEWIDTH },
	{  "50%",  50 },
	{  "70%",  70 },
	{  "85%",  85 },
	{ "100%", 100 },
	{ "125%", 125 },
	{ "150%", 150 },
	{ "175%", 175 },
	{ "200%", 200 },
	{ "300%", 300 },
	{ "400%", 400 },
	{ NULL,     0 }
};

static volatile int sig_arrived = 0;

static void mysighandler(int signum) {
	switch (signum) {
		case SIGTRAP:
			/*
			 * dump core, make the GTK warnings debuggable
			 * by --g-fatal-warnings
			 */
			abort();
			/* unreached */
			break;
		default:
			sig_arrived = 1;
	}
}

static gboolean
idle_check_signal(gpointer user_data)
{
	if (sig_arrived == 0)
		return TRUE;

	gtk_main_quit();

	return FALSE;
}

#if ICONVIEW
static gboolean
idle_fill_thumbs(gpointer user_data)
{
	pdf_browser_contents *ptr = (pdf_browser_contents *)user_data;
	oppdf_doc *doc_ptr = ptr->doc_ptr;
	oppdf_pages	*page;
	GtkTreeIter	iter;
	GdkPixmap	*pixmap;
	cairo_t		*cairo;
	GdkPixbuf	*pixbuf;
	char		*label;
	double		aspect, scale;
	int		pbw, pbh;

	page = &doc_ptr->pages[doc_ptr->thumb_idx];

	g_object_get(G_OBJECT(page->page), "label", &label, NULL);
	aspect = page->ph / page->pw;
	pbw = 100;
	pbh = aspect * pbw;
	scale = (double)pbw / page->pw;

	pixmap = gdk_pixmap_new(ptr->window1->window, pbw, pbh, -1);
	cairo = gdk_cairo_create(pixmap);

	cairo_set_source_rgb(cairo, 1.0, 1.0, 1.0);
	cairo_rectangle(cairo, 0, 0, pbw, pbh);
	cairo_fill(cairo);
	cairo_scale(cairo, scale, scale);
	poppler_page_render(page->page, cairo);

	cairo_destroy(cairo);

	pixbuf = gdk_pixbuf_get_from_drawable(NULL, pixmap, NULL, 0, 0, 0, 0, pbw, pbh);

	gtk_list_store_append(ptr->thumbs, &iter);
	gtk_list_store_set(ptr->thumbs, &iter,
						THUMB_LABEL, label,
						THUMB_ICON, pixbuf,
						-1);
	g_object_unref(pixbuf);

	doc_ptr->thumb_idx++;

	return (doc_ptr->thumb_idx == doc_ptr->n_pages) ? FALSE : TRUE;
}
#endif

int
main(int argc, char *argv[])
{
	int		pdf_size;
	GdkNativeWindow	nw;
	oppdf_doc	*doc_ptr;
	pdf_browser_contents *pdf_browser;

	/* Renice ourselves to the lowest priority. */
	nice(19);

	gtk_set_locale ();
	gtk_init (&argc, &argv);

#ifdef ENABLE_NLS
	bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	textdomain (GETTEXT_PACKAGE);
#endif

	if (argc != 4)
	{
		fprintf(stderr, "invalid number of arguments (%d)\n", argc);
		return 1;
	}

	/* normal quit invoked by the browser plugin part */
	signal(SIGINT,  mysighandler);
	/* catch the TRAP signal used by --g-fatal-warnings */
	signal(SIGTRAP, mysighandler);
	
#if 1
	{
		int	i;

		printf("oppdf handler args\n");
		for (i = 0; i < argc; i++)
			printf("\t%s\n", argv[i]);
		printf("oppdf handler args end\n");
	}
#endif

	if (sscanf(argv[1], "%u", &nw) != 1)
	{
		fprintf(stderr, "window ID expected to be a number\n");
		return 1;
	}

	if (sscanf(argv[2], "%d", &pdf_size) != 1)
	{
		fprintf(stderr, "PDF size expected to be a number\n");
		return 1;
	}

	doc_ptr = pdf_read(pdf_size);

	pdf_browser = create_pdf_browser(nw, doc_ptr);

	pdf_browser_display_data(pdf_browser, argv[3]);

	gtk_widget_grab_focus(pdf_browser->page_spin);

#if ICONVIEW
	/* start filling up thumb images... */
	g_idle_add(idle_fill_thumbs, pdf_browser);
#endif

	gtk_widget_show_all (pdf_browser->window1);

	g_timeout_add(200, idle_check_signal, pdf_browser);

	gtk_main ();

	destroy_pdf_browser(pdf_browser);

	return 0;
}

void oppdf_compute_scale(pdf_browser_contents *ptr) {
	oppdf_doc	*doc_ptr = ptr->doc_ptr;
	oppdf_pages	*pageptr;
	int		page;
	double		aspect;

	/* Not initialized yet? */
	if (doc_ptr->pages == NULL)
		return;

	/*
	 * In continuous mode, we have a uniform scaling
	 * across the whole document. Otherwise, scaling
	 * is page dependent;
	 */
	if (doc_ptr->continuous_mode)
		page = 1;
	else
		page = doc_ptr->current_page;

	/* Safety check */
	if (page > doc_ptr->n_pages)
		page = doc_ptr->n_pages;
	if (page < 0)
		page = 1;

	pageptr = &doc_ptr->pages[page - 1];
	if (pageptr == NULL)
		return;

	/* Not initialized yet? */
	if (pageptr->ph == 0.0 || pageptr->pw == 0.0)
		return;

	aspect = pageptr->ph / pageptr->pw;

	switch (doc_ptr->fit_scale) {
		case BESTFIT:
		{
			double aspect_vp = (double)ptr->img_h / (double)ptr->img_w;
			double w;

			if (aspect_vp < aspect)
				w = (double)ptr->img_h / aspect;
			else
				w = ptr->img_w;
			doc_ptr->scale = w / pageptr->pw;
			break;
		}
		case FITPAGEWIDTH:
			doc_ptr->scale = (double)ptr->img_w / pageptr->pw;
			break;
		default:
			doc_ptr->scale = (double) doc_ptr->fit_scale / (double)100.0;
	}
}

void oppdf_compute_sizes(pdf_browser_contents *ptr) {
	oppdf_doc	*doc_ptr = ptr->doc_ptr;
	int	i;
	int	offset = 0;

	/* Not initialized yet? */
	if (doc_ptr->pages == NULL)
		return;

	if (doc_ptr->continuous_mode) {
		int	virtual_w = 0;

		for (i = 0; i < doc_ptr->n_pages; i++) {
			oppdf_pages *pageptr = &doc_ptr->pages[i];

			pageptr->img_w = doc_ptr->scale * pageptr->pw;
			pageptr->img_h = doc_ptr->scale * pageptr->ph;

			pageptr->offset = offset;
			offset += pageptr->img_h;

			if (virtual_w < pageptr->img_w)
				virtual_w = pageptr->img_w;
		}

		ptr->virtual_w = virtual_w;
		ptr->virtual_h = offset;
	} else {
		oppdf_pages *pageptr = &doc_ptr->pages[doc_ptr->current_page - 1];

		ptr->virtual_w = pageptr->img_w = doc_ptr->scale * pageptr->pw;
		ptr->virtual_h = pageptr->img_h = doc_ptr->scale * pageptr->ph;
	}

	//printf("oppdf_compute_sizes: virtual_w: %d virtual_h: %d\n", ptr->virtual_w, ptr->virtual_h);
}

void oppdf_set_scrollbars(pdf_browser_contents *ptr, double *h, double *v) {
	oppdf_doc	*doc_ptr = ptr->doc_ptr;
	oppdf_pages	*pageptr = &doc_ptr->pages[doc_ptr->current_page - 1];
	gdouble		xval, yval;

	/* Not initialized yet? */
	if (doc_ptr->pages == NULL)
		return;

	//printf("oppdf_set_scrollbars: xvirtual %d xupper %.0lf yvirtual %d yupper %.0lf\n", ptr->virtual_w, hupper, ptr->virtual_h, vupper);

	yval = (v ? *v : (doc_ptr->continuous_mode ? pageptr->offset : 0.0));
	if (yval > ptr->virtual_h - ptr->img_h)
		yval = ptr->virtual_h - ptr->img_h;

	xval = (h ? *h : 0.0);
	if (xval > ptr->virtual_w - ptr->img_w)
		xval = ptr->virtual_w - ptr->img_w;

	//printf("oppdf_set_scrollbars: cont mode: %d, offset: %.0lf\n", doc_ptr->continuous_mode, offset);
	gtk_adjustment_configure(ptr->vadj, yval, 0, ptr->virtual_h, 100, 100, ptr->img_h);
	gtk_adjustment_configure(ptr->hadj, xval, 0, ptr->virtual_w, 100, 100, ptr->img_w);
}

void oppdf_compute_selection(pdf_browser_contents *ptr, int page) {
	oppdf_doc	*doc_ptr = ptr->doc_ptr;

	ptr->search_page = page;
	memset(&ptr->search_rect, 0, sizeof(PopplerRectangle));

	if (ptr->current_search && page) {
		PopplerRectangle *rect = ptr->current_search->data;
		oppdf_pages	*pageptr = &doc_ptr->pages[page - 1];
		double		vpos;

		memcpy(&ptr->search_rect, rect, sizeof(PopplerRectangle));

		/* Convert to pixmap coordinates */
		ptr->search_rect.x1 = ptr->search_rect.x1;
		ptr->search_rect.y1 = pageptr->ph - ptr->search_rect.y1;
		ptr->search_rect.x2 = ptr->search_rect.x2;
		ptr->search_rect.y2 = pageptr->ph - ptr->search_rect.y2;

		if (doc_ptr->continuous_mode) {
			ptr->search_rect.x1 *= doc_ptr->scale;
			ptr->search_rect.y1 *= doc_ptr->scale;
			ptr->search_rect.x2 *= doc_ptr->scale;
			ptr->search_rect.y2 *= doc_ptr->scale;

			vpos = ptr->search_rect.y2 + pageptr->offset;
		} else {
			if (doc_ptr->current_page != page) {
				ptr->render_in_progress = 1;
				gtk_spin_button_set_value(GTK_SPIN_BUTTON(ptr->page_spin), page);
				ptr->render_in_progress = 0;

				oppdf_compute_scale(ptr);
				oppdf_compute_sizes(ptr);
			}

			ptr->search_rect.x1 *= doc_ptr->scale;
			ptr->search_rect.y1 *= doc_ptr->scale;
			ptr->search_rect.x2 *= doc_ptr->scale;
			ptr->search_rect.y2 *= doc_ptr->scale;

			vpos = ptr->search_rect.y2;
		}

		oppdf_set_scrollbars(ptr, &ptr->search_rect.x1, &vpos);
	}

}

void oppdf_display(pdf_browser_contents *ptr)
{
	int		x, y, i;
	oppdf_doc	*doc_ptr = ptr->doc_ptr;
	oppdf_pages	*pageptr;
	cairo_t		*cairo;

	/* Not initialized yet? */
	if (doc_ptr->pages == NULL)
		return;
	/* Not displayed yet? */
	if (!GTK_WIDGET_REALIZED(ptr->window1))
		return;

	x = gtk_adjustment_get_value(ptr->hadj);
	y = gtk_adjustment_get_value(ptr->vadj);

	if (doc_ptr->continuous_mode) {
		int	y1, minpage, maxpage;

		/*
		 * Determing the pages that are visible in the window,
		 * at least in part.
		 */

		y1 = y + ptr->img_h;
		minpage = maxpage = 0;

		for (i = 1; i <= doc_ptr->n_pages; i++) {
			pageptr = &doc_ptr->pages[i - 1];

			if (pageptr->offset <= y && y < pageptr->offset + pageptr->img_h) {
				minpage = i;
				break;
			}

			/* Cleanup the allocated pixmap if it's not visible anymore. */
			if (pageptr->pixmap) {
				g_object_unref(pageptr->pixmap);
				pageptr->pixmap = NULL;
			}
		}

		for (; i <= doc_ptr->n_pages; i++) {
			pageptr = &doc_ptr->pages[i - 1];

			if (y1 <= pageptr->offset)
				break;

			maxpage = i;
		}

		/* Cleanup the rest of the pixmaps */
		for (i = maxpage + 1; i <= doc_ptr->n_pages; i++) {
			pageptr = &doc_ptr->pages[i - 1];

			if (pageptr->pixmap) {
				g_object_unref(pageptr->pixmap);
				pageptr->pixmap = NULL;
			}
		}

		cairo = gdk_cairo_create(ptr->pixmap);

		cairo_set_source_rgb(cairo, 1.0, 1.0, 1.0);
		cairo_rectangle(cairo, 0, 0, ptr->img_w, ptr->img_h);
		cairo_fill(cairo);

		//printf("oppdf_display: continuous minpage %d maxpage %d\n", minpage, maxpage);
		for (i = minpage; i <= maxpage; i++) {
			pageptr = &doc_ptr->pages[i - 1];

			//printf("oppdf_display: painting page %d, y1 %d y %d\n", i, y1, y);

			oppdf_render_single_page(ptr, i);

			cairo_save(cairo);

			cairo_translate(cairo,
				(pageptr->img_w < ptr->img_w ? (ptr->img_w - pageptr->img_w) / 2 : 0) - x,
				pageptr->offset - y);

			gdk_cairo_set_source_pixmap(cairo, pageptr->pixmap, 0, 0);
			cairo_paint(cairo);

			if (ptr->current_search && ptr->search_page == i) {
				cairo_t		*cairo_highlight;
				GdkPixmap	*highlight;
				int		w, h;

				w = abs(ptr->search_rect.x1 - ptr->search_rect.x2);
				h = abs(ptr->search_rect.y1 - ptr->search_rect.y2);

				highlight = gdk_pixmap_new(ptr->window1->window, w, h, -1);
				cairo_highlight = gdk_cairo_create(highlight);
				cairo_set_source_rgb(cairo_highlight, 0.0, 1.0, 0.0);
				cairo_rectangle(cairo_highlight, 0, 0, w, h);
				cairo_fill(cairo_highlight);
				cairo_destroy(cairo_highlight);

				//printf("oppdf_display: highlight in continuous mode, page %d. translate x %.0lf y %.0lf\n",
				//	i,
				//	(pageptr->img_w < ptr->img_w ? (ptr->img_w - pageptr->img_w) / 2 : 0) - x + ptr->search_rect.x1,
				//	pageptr->offset - y + ptr->search_rect.y2);

				cairo_translate(cairo, ptr->search_rect.x1, ptr->search_rect.y2);
				gdk_cairo_set_source_pixmap(cairo, highlight, 0, 0);
				cairo_paint_with_alpha(cairo, 0.50);

				g_object_unref(highlight);
			}

			cairo_restore(cairo);
		}

		cairo_destroy(cairo);
	} else {

		/* Clean up the previously allocated page pixmaps */
		for (i = 1; i <= doc_ptr->n_pages; i++)
		{
			if (i == doc_ptr->current_page)
				continue;
			pageptr = &doc_ptr->pages[i - 1];
			if (pageptr->pixmap)
			{
				g_object_unref(pageptr->pixmap);
				pageptr->pixmap = NULL;
			}
		}

		cairo = gdk_cairo_create(ptr->pixmap);

		cairo_set_source_rgb(cairo, 1.0, 1.0, 1.0);
		cairo_rectangle(cairo, 0, 0, ptr->img_w, ptr->img_h);
		cairo_fill(cairo);

		oppdf_render_single_page(ptr, doc_ptr->current_page);

		pageptr = &doc_ptr->pages[doc_ptr->current_page - 1];

		cairo_save(cairo);

		cairo_translate(cairo,
			(pageptr->img_w < ptr->img_w ? (ptr->img_w - pageptr->img_w) / 2 : 0) - x,
			(pageptr->img_h < ptr->img_h ? (ptr->img_h - pageptr->img_h) / 2 : 0) - y);
		gdk_cairo_set_source_pixmap(cairo, pageptr->pixmap, 0, 0);
		cairo_paint(cairo);

		if (ptr->current_search && doc_ptr->current_page == ptr->search_page) {
			cairo_t		*cairo_highlight;
			GdkPixmap	*highlight;
			int		w, h;

			//printf("oppdf_display: rendering highlight in paged mode\n");

			w = abs(ptr->search_rect.x1 - ptr->search_rect.x2);
			h = abs(ptr->search_rect.y1 - ptr->search_rect.y2);

			highlight = gdk_pixmap_new(ptr->window1->window, w, h, -1);
			cairo_highlight = gdk_cairo_create(highlight);
			cairo_set_source_rgb(cairo_highlight, 0.0, 1.0, 0.0);
			cairo_rectangle(cairo_highlight, 0, 0, w, h);
			cairo_fill(cairo_highlight);
			cairo_destroy(cairo_highlight);

			cairo_translate(cairo, ptr->search_rect.x1, ptr->search_rect.y2);
			gdk_cairo_set_source_pixmap(cairo, highlight, 0, 0);
			cairo_paint_with_alpha(cairo, 0.50);

			g_object_unref(highlight);
		}

		cairo_restore(cairo);

		cairo_destroy(cairo);
	}

	gtk_image_set_from_pixmap(GTK_IMAGE(ptr->image), ptr->pixmap, NULL);
}

void oppdf_render_single_page(pdf_browser_contents *ptr, int page)
{
	oppdf_doc	*doc_ptr = ptr->doc_ptr;
	oppdf_pages	*pageptr;
	cairo_t		*cairo;

	pageptr = &doc_ptr->pages[page - 1];

	if (pageptr->pixmap) {
		int	w, h;

#if GTK_CHECK_VERSION(2,24,0)
		/* gdk_drawable_get_size() is deprecated since 2.24.0 */
		gdk_pixmap_get_size(pageptr->pixmap, &w, &h);
#else
		gdk_drawable_get_size(GDK_DRAWABLE(pageptr->pixmap), &w, &h);
#endif

		/* Already rendered at the correct size */
		if (pageptr->img_w == w && pageptr->img_h == h)
		{
			//printf("oppdf_render_single_page: already rendered at the correct size\n");
			return;
		}

		//printf("oppdf_render_single_page: incorrect size, free pixmap\n");
		g_object_unref(pageptr->pixmap);
	}

	//printf("oppdf_render_single_page: rendering page %d\n", page);
	pageptr->pixmap = gdk_pixmap_new(ptr->window1->window, pageptr->img_w, pageptr->img_h, -1);
	cairo = gdk_cairo_create(pageptr->pixmap);

	/* Fill up with white */
	cairo_set_source_rgb(cairo, 1.0, 1.0, 1.0);
	cairo_rectangle(cairo, 0, 0, pageptr->img_w, pageptr->img_h);
	cairo_fill(cairo);

	cairo_save(cairo);

	/* Render the scaled document page */
	cairo_scale(cairo, doc_ptr->scale, doc_ptr->scale);
	poppler_page_render(pageptr->page, cairo);

	cairo_restore(cairo);

	/* Draw a black line around the document */
	cairo_set_line_width(cairo, 1.0);
	cairo_set_source_rgb(cairo, 0.0, 0.0, 0.0);
	cairo_rectangle(cairo, 0, 0, pageptr->img_w - 1, pageptr->img_h - 1);
	cairo_stroke(cairo);

	cairo_destroy(cairo);
}

int oppdf_search_new(pdf_browser_contents *ptr, int start_page) {
	oppdf_doc	*doc_ptr = ptr->doc_ptr;
	GList	*list = NULL;
	int	i;
	const gchar *search_text = gtk_entry_get_text(GTK_ENTRY(ptr->find_entry));

	if (strlen(search_text) == 0)
		return 0;

	for (i = start_page; i <= doc_ptr->n_pages; i++) {
		oppdf_pages	*pageptr = &doc_ptr->pages[i - 1];

		list = poppler_page_find_text(pageptr->page, search_text);
		if (list) {
			printf("oppdf_search_new: '%s' found on page %d\n", search_text, i);
			break;
		}
	}

	/* Try from the start */
	if (list == NULL) {
		for (i = 1; i < start_page; i++) {
			oppdf_pages	*pageptr = &doc_ptr->pages[i - 1];

			list = poppler_page_find_text(pageptr->page, search_text);
			if (list) {
				printf("oppdf_search_new: '%s' found on page %d\n", search_text, i);
				break;
			}
		}
	}

	if (list == NULL) {
		error_dialog	*error_dlg;

		error_dlg = create_error();
		gtk_label_set_label(GTK_LABEL(error_dlg->label), _("Text not found"));
		gtk_dialog_run(GTK_DIALOG(error_dlg->error));
		destroy_error(error_dlg);

		return 0;
	}

	ptr->search_list = list;
	ptr->current_search = g_list_first(list);
	ptr->search_page = i;
	return i;
}

int oppdf_search_next(pdf_browser_contents *ptr) {
	oppdf_doc	*doc_ptr = ptr->doc_ptr;
	GList	*next;
	int	new_page;

	next = ptr->current_search->next;

	if (next) {
		ptr->current_search = next;
		return ptr->search_page;
	}

	oppdf_search_free(ptr);

	new_page = ptr->search_page + 1;
	if (new_page > doc_ptr->n_pages)
		new_page = 1;

	return oppdf_search_new(ptr, new_page);
}

int oppdf_search_new_prev(pdf_browser_contents *ptr, int start_page) {
	oppdf_doc	*doc_ptr = ptr->doc_ptr;
	GList	*list = NULL;
	int	i;
	const gchar *search_text = gtk_entry_get_text(GTK_ENTRY(ptr->find_entry));

	if (strlen(search_text) == 0)
		return 0;

	for (i = start_page; i >= 1; i--) {
		oppdf_pages	*pageptr = &doc_ptr->pages[i - 1];

		list = poppler_page_find_text(pageptr->page, search_text);
		if (list) {
			printf("oppdf_search_new_prev: '%s' found on page %d\n", search_text, i);
			break;
		}
	}

	/* Try from the end */
	if (list == NULL) {
		for (i = doc_ptr->n_pages; i > start_page; i--) {
			oppdf_pages	*pageptr = &doc_ptr->pages[i - 1];

			list = poppler_page_find_text(pageptr->page, search_text);
			if (list) {
				printf("oppdf_search_new_prev: '%s' found on page %d\n", search_text, i);
				break;
			}
		}
	}

	if (list == NULL) {
		error_dialog	*error_dlg;

		error_dlg = create_error();
		gtk_label_set_label(GTK_LABEL(error_dlg->label), _("Text not found"));
		gtk_dialog_run(GTK_DIALOG(error_dlg->error));
		destroy_error(error_dlg);

		return 0;
	}

	ptr->search_list = list;
	ptr->current_search = g_list_last(list);
	ptr->search_page = i;
	return i;
}


int oppdf_search_prev(pdf_browser_contents *ptr) {
	oppdf_doc	*doc_ptr = ptr->doc_ptr;
	GList	*prev;
	int	new_page;

	prev = ptr->current_search->prev;

	if (prev) {
		ptr->current_search = prev;
		return ptr->search_page;
	}

	oppdf_search_free(ptr);

	new_page = ptr->search_page - 1;
	if (new_page < 1)
		new_page = doc_ptr->n_pages;

	return oppdf_search_new_prev(ptr, new_page);
}

/* poppler_rectangle_free wrapper to conform to GDestroyNotify */
static void oppdf_poppler_rectangle_free(gpointer data, gpointer user_data) {
	poppler_rectangle_free(data);
}

void oppdf_search_free(pdf_browser_contents *ptr)
{
	if (ptr->search_list) {
#if 0
		g_list_free_full(ptr->search_list, oppdf_poppler_rectangle_free);
#else
		g_list_foreach (ptr->search_list, (GFunc) oppdf_poppler_rectangle_free, NULL);
		g_list_free (ptr->search_list);
#endif
		ptr->search_list = NULL;
		ptr->current_search = NULL;
	}
}
